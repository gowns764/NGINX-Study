# 고성능 부하분산

## 1 소개
- 부하가 지속적으로 증가할 수록 동일한 시스템을 추가 투입하는 아키텍처 기술을 **수평적인 확장**이라 부른다.
- 부하를 분산하는 과정에서는 사용자 경험을 해치지 않아야 한다.
- 엔진엑스가 사용자에게 제공하는 애플리케이션 동작에는 문제가 없어야 한다.

## 2 HTTP 부하분산
- 엔진엑스의 upstream 블록과 http 모듈을 이용해 HTTP 서버 간에 부하를 분산한다.
- ```
  upstream backend {
      server 10.10.12.45:80     weight=1;
      server app.example.com:80 weight=2;
      server spare.example.com:80 backup;
  }
  server {
      location / {
          proxy_pass http://backend;
      }
  }
  ```
- 이 엔진엑스 설정은 80 포트를 사용하는 HTTP 서버 두 대로 부하를 분산한다.
    - 설정한 프라이머리 서버 두 대에 문제가 발생해 연결이 불가능하면 backup 서버로 지정한 서버를 사용한다.
    - 지정한 weight 매갸변수 값에 따라 두 번째 서버는 첫 번째 서버보다 두 배 많은 요청을 받는다.
    - weight의 기본값은 1이며 생략할 수 있다.
- HTTP upstream 모듈을 이용해 HTTP 프로토콜 요청에 대한 부하분산 방식을 정의한다.
    - 부하분산을 위한 목적지 풀은 유닉스 소켓, IP 주소, DNS 레코드 혹은 이들의 조합으로 구성한다.
    - 또한, 개별 요청에 대해 어떤 업스트림 서버를 할당할지 매개변수로 정의한다.
- 각 업스트림 대상은 server 지시자로 설정한다.
    - server 지시자는 유닉스 소켓, IP 주소, FQDN 형식으로 표시된 도메인 정보 등을 몇 가지 추가 매개변수와 함께 지정한다.
    - 매개변수는 요청을 적절한 목적지로 전달하도록 추가 제어 방법을 제공한다.
    - 이러한 매개변수는 분산 알고리즘에 가중치를 적용하거나 서버가 어떤 상태인지 알려주며, 서버 가용 여부를 판단하는 방법 등을 포함한다.

## 3 TCP 부하분산
- 엔진엑스의 upstream 블록과 stream 모듈을 이용해 TCP 서버 간에 부하를 분산한다.
- ```
  stream {
    upstream mysql_read {
        server read1.example.com:3306     weight=5;
        server read2.example.com:3306
        server 10.10.12.34:3306           backup;
    }
    server {
        listen 3306;
        proxy_pass mysql_read;
    }
  }
  ```
- 이 엔진엑스 설정의 server 블록은 3306 포트로 TCP 요청을 받아읽기 전용 복제본 두 대로 구성된 MySQL 서버로 부하를 분산한다.
  - 만약, 프라이머리로 지정한 MySQL 서버 두 대 모두가 다운되면 backup 매개변수로 지정한 서버로 요청을 전달한다.
- 엔진엑스 설치 전후 설정을 바꾸지 않았다면 엔진엑스의 기본 설정 파일 경로인 conf.d 폴더는 http 블록에 포함된다.
  - 따라서, stream 모듈을 이용한 이 설정은 stream.conf.d라는 별도의 폴더를 생성해 저장하는 것이 좋다.
  - 경로를 nginx.conf 파일의 stream 블록에 추가해 엔진엑스가 참조하도록 한다.
    - /etc/nginx/nginx.conf 설정 파일 :
    - ```
      user nginx;
      worker_process auto;
      pid /run/nginx.pid

      stream {
          include /etc/nginx/stream.conf.d/*.conf;
      }
      ```
    - /etc/nginx/stream.conf.d/mysql_read.conf 설정 파일 :
    - ```
      upstream mysql_read {
          server read1.example.com:3306     weight=5;
          server read2.example.com:3306;
          server 10.10.12.34:3306           backup;
      }
      server {
          listen 3306;
          proxy_pass mysql_read;
      }
      ```
- http와 stream 모듈의 가장 큰 차이점은 OSI 모델의 서로 다른 계층에서 동작한다는 점이다.
    - http 컨텍스트는 7계층, stream 컨텍스트는 4계층에서 동작한다.
    - http 모듈이 HTTP 프로토콜을 완전히 이해하도록 특별히 설계된 반면, stream 모듈은 패킷의 전달 경로 결정과 부하분산에 더 중점을 둔다.
    - 엔진엑스에서 TCP 부하분산은 stream 모듈을 이용해 정의한다.
    - http 모듈과 마찬가지로 stream 모듈도 업스트림 서버 풀을 만들거나 수신할 개별 서버를 지정한다.
    - 서버가 특정 포트로 요청을 받게 하려면 수신할 포트를 설정에 추가하거나 IP 주소와 함께 포트 번호를 기술한다.
    - 정의한 서버가 다른 서버로 요청을 전달하는 리버스 프록시 서버인지 혹은 일반적인 업스트림 풀에 포함된 서버인지에 관계없이 목적지 서버 목록에 정의한다.
- stream 모듈을 이용하는 경우 옵션을 통해 TCP 연결과 관계된 리버스 프록시의 여러 속성을 변경할 수 있다.
    - 유효한 SSL/TLS 인증서 제한, 타임아웃, 킵얼라이브 시간 설정 등이 있다.
    - 일부 옵션은 엔진엑스 변수를 값으로 사용할 수 있는데, 다운로드 속도 제한이나 SSL/TLS 인증서 유효성 검사에서 사용할 이름이 지정된 변수 혹은 이 변수가 포함된 값을 옵션에 사용할 수 있다.
- TCP 부하분산을 위한 업스트림 블록은 HTTP의 업스트림 블록과 매우 유사하다.
    - 목적지를 정의하는 데 유닉스 소켓, IP 주소, FQDN을 사용하며 가중치, 최대 동시 연결 수, DNS 리졸버, 연결 증가 주기, 서버의 상태 매개변수 등을 사용한다.

## 4 UDP 부하분산
- udp로 정의된 upstream 블록을 엔진엑스의 stream 모듈에서 사용해 UDP 서버 간에 부하를 분산한다.
- ```
  stream {
      upstream ntp {
          server ntp1.example.com:123   weight=2;
          server ntp2.example.com:123;
      }

      server {
          listen 123udp;
          proxy_pass ntp;
      }
  }
  ```
- 예제의 설정은 UDP 프로토콜을 사용해 NTP 서버 두 대로 부하를 전달한다.
    - UDP 프로토콜의 부하분산 설정은 listen 지시자에 udp 매개변수만 추가하면 된다.
- 부하분산이 적용된 서비스에서 클라이언트와 서버가 패킷을 여러 번 주고받아야 한다면 reuseport 매개변수를 사용한다.
    - 부하분산이 적용된 서비스는 오픈VPN, VoIP, 가상 데스크톱 환경, DTLS 등이 있다.
    - 다음 예제는 엔진엑스를 통해 OpenVPN으로 패킷을 전달해주는 설정이다.
    - ```
      stream {
          server {
              listen 1195 udp reuseport;
              proxy_pass 127.0.0.1:1194;
          }
      }
      ```
- UDP 부하분산의 TCP 부하분산에 대한 가장 큰 차이점은 listen 지시자를 통해 UDP 데이터그램을 처리할 소켓을 지정한다는 점이다.
    - 데이터그램을 다룰 때는 TCP 부하분산에서 사용하지 않는 지시자를 몇 가지 사용한다.
    - 대표적으로 엔진엑스가 업스트림 서버로부터 수신할 것으로 예상되는 응답의 크기를 지정하는 데 procy_response 지시자를 사용한다.
        - 이 지시자를 사용하지 않으면 proxy_timeout 지시자의 제한값이 되기 전까지 무제한으로 응답을 처리한다.
        - proxy_timeout은 연결을 닫기 전에 목적지 서버로의 읽기, 쓰기 작업 완료를 기다리는 시간을 지정하는 데 사용한다.
- reuseport 매개변수는 엔진엑스가 워커 프로세스별로 개별 수신 소켓을 만들어 사용하도록 한다.
    - 커널은 엔진엑스로 보내야 하는 연결들을 워커 프로세스 단위로 분산하고, 클라이언트와 서버가 주고받는 여러 패킷을 동시에 처리할 수 있다.

## 5 부하분산 알고리즘
- 서로 다른 특성을 갖는 작업이나 사양이 다른 서버로 구성된 서버 풀로 인해 라운드 로빈 방식의 부하분산이 적합하지 않은 경우, 엔진엑스가 제공하는 다른 부하분산 알고리즘을 사용한다.
    - 연결이 적은 서버를 먼저 활용하는 **리스트 커넥션**, 응답 속도가 빠른 서버를 우선 사용하는 **리스트 타임**, 특정 문자열 기반 해시를 활용하는 **제네릭 해시**, 임의 서버를 할당하는 **랜덤**, IP 주소 기반 해시를 사용하는 **IP 해시** 등이 있다.
    - ```
      upstream backend {
          least_conn;
          server backend.example.com;
          server backend1.example.com;
      }
      ```
    - 필요에 따라 알고리즘을 선택하고 알고리즘 동작의 세부 사항도 설정할 수 있다.

### 5.1. 라운드 로빈
- 기본값으로 설정된 부하분산 방법이다.
- 업스트림 풀에 지정된 서버의 순서에 따라 요청을 분산한다.
- 업스트림 서버의 가용량이 다양하다면 가중치를 적용한 하운드 로빈 방식도 설정할 수 있다.
    - 가중치로 더 높은 정수값이 지정된 서버는 더 많은 요청을 받는다.
    - 가중치는 단순히 가중치 평균의 통계적 확률에 따라 계산된다.

### 5.2. 리스트 커넥션
- **least_conn**
- 엔진엑스와 연결 수가 가장 적은 업스트림 서버로 요청을 전달해 부하를 분산한다.
- 어떤 서버로 요청을 보낼지 계산할 때 가중치를 설정한다.

### 5.3. 리스트 타임
- **least_time**
- 엔진엑스 플러스에사민 사용할 수 있는 방법이다.
- 연결 수가 가장 적은 업스트림 서버로 요청을 전달하지만, 이 중 응답 시간이 가장 빠른 서버를 우선시한다.
- 가장 복잡한 부하분산 알고리즘으로 높은 성능이 필요한 웹 애플리케이션에 적합하다.
- 처리 시간이 길어도 항상 서버가 성능이 낮거나 과부화가 걸린 것은 아니다.
    - 따라서, 많은 처리가 필요한 요청은 비동기로 처리하는 것이 나을 수 있다.
- 리스트 타임 알고리즘을 사용할 때는 **header**나 **last_byte** 매개변수 중 하나를 지정한다.
    - header를 사용하면 업스트림 서버로부터 응답 헤더를 받을 때까지 소요된 시간을 사용한다.
    - last_byte를 사용하면 헤더 뿐만 아니라 응답 전체를 받을 때까지 소요된 시간을 사용한다.

### 5.4. 제네릭 해시
- **hash**
- 엔진엑스는 수신한 요청의 해시흫 생성하고 업스트림 서버 선택에 활용해 부하를 분산한다.
- 요청을 처리할 서버를 선택하는 데 깊이 개입해야 할 때나 캐시가 있을 확률이 높은 서버로 요청을 전달하고 싶을 때 유용하다.
- 서버가 업스트림 풀에서 추가되거나 삭제되면 해시 처리된 요청이 재분배된다.
- **consistent** 옵션 매개변수를 사용하면 재분배의 영향을 최소화할 수 있다.

### 5.5. 랜덤
- **random**
- 엔진엑스가 업스트림 풀에 지정된 서버를 임의로 선책해 요청을 전달하며 이때 업스트림 서버에 지정된 가중치를 고려한다.
- 매개변수로 **two [method]**를 사용하면 먼저 서버 두 대를 임의로 선택하고 method에 지정된 알고리즘을 이용해 2차 부하분산을 한다.
    - method 값을 생략하면 기본 알고리즘은 least_conn으로 지정된다.

### 5.6. IP 해시
- **ip_hash**
- HTTP에서만 동작하는 방법으로, IP 주소를 이용해 해시를 생성한다.
- 이 방식을 통해 사용자는 업스트림 서버에 문제가 없는 한 같은 서버로 할당된다.
- 이러한 특성은 세션 상태가 관리되지 않는 환경이나 세션 상태가 애플리케이션 공유 메모리를 통해 공유되지 않는 경우에 유용하다.